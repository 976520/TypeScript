//// [tests/cases/compiler/dependentReturnType10.ts] ////

=== dependentReturnType10.ts ===
interface Animal {
    name: string;
>name : string
>     : ^^^^^^

    species: string;
>species : string
>        : ^^^^^^
}

interface Dog extends Animal {
    breed: string;
>breed : string
>      : ^^^^^^
}

type GreetRet<T> =
>GreetRet : GreetRet<T>
>         : ^^^^^^^^^^^

    T extends string ? string :
    T extends { name: string } ? { greeting: string, breed: string } :
>name : string
>     : ^^^^^^
>greeting : string
>         : ^^^^^^
>breed : string
>      : ^^^^^^

    never;

function greet<T extends string | Dog>(animal: T): GreetRet<T> {
>greet : <T extends string | Dog>(animal: T) => GreetRet<T>
>      : ^ ^^^^^^^^^            ^^      ^^ ^^^^^           
>animal : T
>       : ^

    if (typeof animal === "string") {
>typeof animal === "string" : boolean
>                           : ^^^^^^^
>typeof animal : "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function"
>              : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>animal : T
>       : ^
>"string" : "string"
>         : ^^^^^^^^

        return `hello, ${animal}`
>`hello, ${animal}` : string
>                   : ^^^^^^
>animal : T & string
>       : ^^^^^^^^^^
    }
    return { greeting: `woof, ${animal.name}`, breed: animal.breed }
>{ greeting: `woof, ${animal.name}`, breed: animal.breed } : { greeting: string; breed: string; }
>                                                          : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>greeting : string
>         : ^^^^^^
>`woof, ${animal.name}` : string
>                       : ^^^^^^
>animal.name : string
>            : ^^^^^^
>animal : Dog
>       : ^^^
>name : string
>     : ^^^^^^
>breed : string
>      : ^^^^^^
>animal.breed : string
>             : ^^^^^^
>animal : Dog
>       : ^^^
>breed : string
>      : ^^^^^^
}

type BadRet<T> =
>BadRet : BadRet<T>
>       : ^^^^^^^^^

    T extends {} ? void :
    T extends string ? number :
    never;

function badFun<T extends { a: string } | string>(x: T): BadRet<T> {
>badFun : <T extends { a: string; } | string>(x: T) => BadRet<T>
>       : ^ ^^^^^^^^^                       ^^ ^^ ^^^^^         
>a : string
>  : ^^^^^^
>x : T
>  : ^

    if (typeof x === "string") {
>typeof x === "string" : boolean
>                      : ^^^^^^^
>typeof x : "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function"
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>x : T
>  : ^
>"string" : "string"
>         : ^^^^^^^^

        return 1
>1 : 1
>  : ^
    }
    return;
}

declare let arg2: { a: string } | string;
>arg2 : string | { a: string; }
>     : ^^^^^^^^^^^^^^      ^^^
>a : string
>  : ^^^^^^

const badRet = badFun(arg2);
>badRet : void
>       : ^^^^
>badFun(arg2) : void
>             : ^^^^
>badFun : <T extends { a: string; } | string>(x: T) => BadRet<T>
>       : ^ ^^^^^^^^^                       ^^ ^^ ^^^^^         
>arg2 : string | { a: string; }
>     : ^^^^^^^^^^^^^^      ^^^

